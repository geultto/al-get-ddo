좋은 코드는 뭐냐?
메모리를 적게 쓰냐? 빠르냐? 가독성이 좋은거냐?
뭐가 고려되야 할 지는 상황에 따라 다르다.

속도, 메모리 사용은 좀 나중에 봐야한다.

코드가 실행되는 데 걸리는 시간은 어떻게?
사실 제일 쉬운 건 타이밍 펑션.
performance.now()

똑같은 데이터를 다루지만, add2가 훨씬 훨씬 빠르게.
1초대와 0.0001초대의 비교.

이렇게 비교하는 건 좋은 방법은 아님.

기기마다 사양 다를수도 있고.
똑같은 기계가 다른 시간을 기록할 수도 있음.
속도 측정의 정확도가 엄청 정확하진 않다.

이걸 비교하기 위해서 빅오 표기법이 있다

컴퓨터가 해야하는 연산의 개수를 비교해라.

n이 어떤 값이 들어오든, add2는 3번의 계산.
add1은, 루프 안에 있는 한 번의 연산이 계속 이어짐. 
n이 20이면 20번… n 개수의 연산.

정확한 숫자는 중요하지 않다.
전체적 추세를 보는 게 중요하다.


Big O
입력의 크기와 실행시간의 관계
여기까진 시간복잡도
——


공간복잡도 (보조 공간 복잡도)

알고리즘 자체
n의 증가 추세를 보는 게 Big O 의 중요함..

불, 숫자, undefined, null은 불변 공간
문자열 - O(n) 공간
배열, 객체 (reference 타입) 도 - O(n) 공간




—

어떤 알고리즘은 그렇게 심플하게 안 떨어지기도 한다…
logarthms~ 

로그함수는 지수함수의 역함수~


——

객체

정렬되지 않은 데이터 구조,
key-value

정렬이 필요 없을 때
빠른 접근, 입력, 제거를 원할 때.
정렬만 안 되어 있지 나머지는 다 빠르다.

삽입, 삭제, 접근이 모두 O(1)
탐색은 O(N)


시작과 끝이 없고, 아무데나 데이터를 넣어도 
영향이 없다. 그저 key 에 접근하니까.
해쉬 테이블, 맵 섹션에서 더 deep dive 할 것임.


이 안에 속성이 많을수록 탐색은 시간이 걸리게 됨.

keys, values, entries, … 는 O(N)
hasOwnProperty 는 O(1) 
탐색은 사실 꽤 희귀하다.. 객체에서는.

—
배열

정렬되어 있다.
ordered.

연산을 하는 시간은 더 걸릴 수 있다.
뭐든 섞어서 넣을수도 있고, el마다 붙어있는 index.

	⁃	정렬되어 있는 데이터를 위하여 사용
	⁃	성능을 희생해야 할 때 있음. 입력/삭제 때.
	⁃	접근은 O(1)

배열의 길이는 중요하지 않음.
접근은 그냥 9천번째 원하면 그거 있는지 확인하고 가져올 뿐. 그래서 O(1)

배열 끝에 요소를 추가하는 push는 O(1)
배열 앞에 추가할 때는, 뒤에 있는 인덱스들 다 밀고 들어가야 하기 때문에.. O(N)
맨 앞에 있는걸 제거해도 마찬가지. O(N)

배열 앞에 추가, 제거는  효율적이진 않다는 걸 알아라. 쓰지 말라는 게 아니다.
push, pop > unshift, shift


탐색도 O(N).

다 암기할 필요는 없어…
이 숫자들 어떻게 나오는 지 이해해라 그냥.


일반적으로 배열을 건드리는 메서드는 O(N)이라고 생각해라~ 그럼 편해.

—

알고리즘이란 뭘까?
특정 작업을 달성하기 위한 과정이나 일련의 단계

왜 알아야 할까?
… 그냥 기본임.

	1.	문제 해결을 위한 전략을 세우고
	2.	일반적인 문제해결 패턴을 마스터하는 것


	⁃	문제를 이해해라
	⁃	예시를 알아본다
	⁃	문제 세분화
	⁃	문제 해결, 단순화
	⁃	문제 복습, 재구성

—

문제 해결..


문제 해결을 위한 단계를 짜놓을 필요가 있음.
먼저, 문제를 이해해라.. 그게 제일 중요하다

시간적 제약이 있는 상황에선 무조건 해결해야한다 라는 압박감이 있을 수 있다.
특히, 프로그래밍… 

코드 치기전에, 정확히 문제를 이해해보는 시간을 가져야한다.

무언가를 구축하고자 하지만 접근법을 모르겠다면..

	⁃	이 질문을 내식대로 바꿀 수 있는가?
	⁃	어떤 입력값을 갖고있고
	⁃	어떤 출력값을 갖고있고, 어떤 결과로 나와야 할까?
	⁃	입력값이 출력값을 결정할 수 있는가?
	⁃	어떻게 레이블링할것인가.


심플한 예를 들어서 생각해보고….
예시를 두세개 작성해봐라. 


initiated conversation first


문제 세분화.

해결책의 기본적 구성 요소를 정해라.
단계 틀 잡고 집중할 수 있게.


어디서 막히더라도 시작점을 안다면
거기서부터 시작하는 게 좋다. 
문제 이해했고, 예시도 만들었고, 세분화도 했다..

단순화. 가장 어려운 부분은 무시하고
단순한 것들을 작성한다음, 다시 어려운 부분이 가능하다면 통합시키는 것임.

Frequency Counters

nested loops, O(n^2) 를 피할 수 있는 방법..


